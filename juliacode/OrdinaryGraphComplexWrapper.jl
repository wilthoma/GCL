#######################################################################
# provides a wrapper around the existing C++ code for generating 
# lists of ordinary graphs and the contraction operator.
#
# Keeps 2 copies of each file, one generated by the C++ code, 
# and one translated into "proper" format
#######################################################################


# here the translated copies of files reside
ordinaryDataDirWrapperOdd = joinpath(DATA_DIR, "ordinary_wrapper/oddedge/")
ordinaryDataDirWrapperEven = joinpath(DATA_DIR, "ordinary_wrapper/evenedge/")

# here is where the C++ code creates its files
ordinaryDataDirWrapperOddC = joinpath(DATA_DIR, "ordinary_wrapper/cdata/odd/")
ordinaryDataDirWrapperEvenC = joinpath(DATA_DIR, "ordinary_wrapper/cdata/even/")

# Path to the C++ program
programC = "TODO/gradiff"


imgBaseDir = "img/"

type OrdinaryGraphVectorSpaceWrapper <: GraphVectorSpace{SmallGraph}
  nVertices :: Int
  nLoops :: Int
  evenEdges :: Bool
end

function get_file_name(self::OrdinaryGraphVectorSpaceWrapper)
  dataDir = self.evenEdges ? ordinaryDataDirWrapperEven : ordinaryDataDirWrapperOdd
  s = @sprintf "gra%d_%d.g6" self.nVertices self.nLoops
  return string(dataDir, s)
end

"""
  The cohomological degree, for dimension = 2 if edges are odd and dimension 3 if edges are even
"""
function get_degree(self::OrdinaryGraphVectorSpaceWrapper)
  nEdges = self.nLoops + self.nVertices -1
  return self.evenEdges ? 3*self.nVertices-3-2*nEdges : 2*self.nVertices-2-nEdges
end

"""
  The list file name to which the C++ code writes the list. 
"""
function get_file_nameC(self::OrdinaryGraphVectorSpaceWrapper)
  degree = get_degree(self)
  if self.evenEdges
    s = @sprintf "graev%d_%d.g6" self.nVertices degree
    return joinpath(ordinaryDataDirWrapperEvenC, s)
  else
    s = @sprintf "gra%d_%d.g6" self.nVertices degree
    return joinpath(ordinaryDataDirWrapperOddC, s)
  end 
end



function get_svg_dir(self::OrdinaryGraphVectorSpaceWrapper)
  dataDir = self.evenEdges ? ordinaryDataDirWrapperEven : ordinaryDataDirWrapperOdd
  s = @sprintf "imgs%d_%d/" self.nVertices self.nLoops
  return string(dataDir, imgBaseDir, s)
end


function get_color_counts(self::OrdinaryGraphVectorSpaceWrapper)
        error("This routine should not be called, this is only a wrapper")
end

function get_fstring(self::OrdinaryGraphVectorSpaceWrapper)
        error("This routine should not be called, this is only a wrapper")
end

"""Check whether the T graded subspace can in principle be non-empty.
   For each such T, a file is expected. Otherwise the corresponding
   graded component is considered not computed yet."""
function is_valid(self::OrdinaryGraphVectorSpaceWrapper)
        nEdges = self.nLoops + self.nVertices -1
        # at least trivalent, and simple
        return  (3*self.nVertices <= 2*nEdges) && self.nVertices > 0 && self.nLoops >= 0 && nEdges <= self.nVertices*(self.nVertices-1)/2
end

function get_base(self::OrdinaryGraphVectorSpaceWrapper)
    return OrdinaryGraphVectorSpace(self.nVertices, self.nLoops, self.evenEdges)
end

"""Produces a set of graphs whose isomorphism classes span the T component of the vector space.
   (Not necessarily freely!)"""
function get_generating_graphs(self::OrdinaryGraphVectorSpaceWrapper)
    error("This routine should not be called, this is only a wrapper")
end

"""For G a graph and p a permutation of the edges, returns the sign induced by the relabelling by p.
   Here vertex j becomes vertex p[j] in the new graph."""
function get_perm_sign(self::OrdinaryGraphVectorSpaceWrapper, G::SmallGraph, p)
    return get_perm_sign(get_base(self), G, p)
end

"""Converts the graph to a graphviz dot format string.
   This method is used only for visualization, not for computation."""
function get_dot(self::OrdinaryGraphVectorSpaceWrapper, G)
    return get_dot(get_base(self), G)
end


# -----  Contraction operator --------

type ContractDOrdinaryWrapper <: GraphOperator{SmallGraph,SmallGraph}
  # source
  nVertices :: Int
  nLoops :: Int
  evenEdges :: Bool
end

"""Retrieve the file name of the file storing the matrix list for the operator."""
function get_file_name(self::ContractDOrdinaryWrapper)
  dataDir = self.evenEdges ? ordinaryDataDirWrapperEven : ordinaryDataDirWrapperOdd
  s = @sprintf "contractD%d_%d.txt" self.nVertices self.nLoops
  return string(dataDir, s)
end

function get_unique_file_name(self::ContractDOrdinaryWrapper)
  prefix = self.evenEdges ? "ordinary_even_" : "ordinary_odd_"
  s = @sprintf "contractDWrapper%d_%d.sms" self.nVertices self.nLoops
  return string(prefix, s)
end

"""Returns target graph vector space."""
function get_target(self::ContractDOrdinaryWrapper)
  return OrdinaryGraphVectorSpaceWrapper(self.nVertices-1, self.nLoops, self.evenEdges)
end

"""
Returns the GraphVectorSpace on which this operator acts
"""
function get_source(self::ContractDOrdinaryWrapper)
  return OrdinaryGraphVectorSpaceWrapper(self.nVertices, self.nLoops, self.evenEdges)
end

function get_file_nameC(self::ContractDOrdinaryWrapper)
  svs = get_source(self)
  degree = get_degree(svs)

  if self.evenEdges
    s = @sprintf "graev%d_%d.txt" self.nVertices degree
    return joinpath(ordinaryDataDirWrapperEvenC, s)
  else
    s = @sprintf "gra%d_%d.txt" self.nVertices degree
    return joinpath(ordinaryDataDirWrapperOddC, s)
  end 
end


"""For G a graph returns a list of pairs (GG, x),
   such that (operator)(G) = sum x GG.
"""
function operate_on(self::ContractDOrdinaryWrapper, G::SmallGraph)
    error("This should not be called")
end

function get_work_estimate(self::OrdinaryGraphVectorSpaceWrapper)
  # give estimate of number of graphs
  nEdges = self.nLoops + self.nVertices -1
  n = self.nVertices
  return binomial(div(n*(n-1),2), nEdges) / factorial(n)
end

function get_work_estimate(self::ContractDOrdinaryWrapper)
  # give estimate of number of graphs
  vs = get_source(self)
  nEdges = vs.nLoops + vs.nVertices -1
  return get_work_estimate(vs) * nEdges
end


# ------ Overloads of creation functions ---------------
"""
Creates the list file for a single graph vector space.
importOnly: if true, the C++ code is not called, only existing files are imported
"""
function createListFile(self::OrdinaryGraphVectorSpaceWrapper;importOnly=false, skipExisting=false)
        outFile = get_file_name(self)
        outFileC = get_file_nameC(self)
        outDir = dirname(outFile)
        outDirC = dirname(outFileC)
    
        if skipExisting && isfile(outFile)
            println("Skipped") 
            return
        end

        if !isdir(outDir)
            mkpath(outDir)
        end

        println( string( "Creating File ",outFile,"...") )
        #println("welt")

        if !isfile(outFileC)
          if importOnly
             println( outFileC * ": file not present, aborting." )
             return
          else
             if !isdir(outDirC)
                mkpath(outDirC)
             end
             println( "Calling external program." )
             degree = get_degree(self)
             if self.evenEdges
                run(`$programC -l -e -d$degree $(self.nVertices) $outFileC`)
             else
                run(`$programC -l -d$degree $(self.nVertices) $outFileC`)
             end
          end
        end

        if isfile(outFileC)
            cp(outFileC, outFile)
            println( "copied." )
        else
           println("failed!")
        end
        
end


"""
Creates the matrix file that holds the operator.
The corresponding list files for source and target
must exist when calling this function.
"""
function createOperatorFile(self::ContractDOrdinaryWrapper;importOnly=false, skipExisting=false)

        #vs = get_source(self)
        outFile = get_file_name(self)
        outFileC = get_file_nameC(self)
        #inListFileC = get_file_nameC(vs)
        #tvs = get_target(self)
        #tgtListFileC = get_file_nameC(tvs)

        if skipExisting && isfile(outFile)
            println("Skipped") 
            return
        end

        println( string( "Creating File ",outFile,"...") )

        if !isfile(outFileC)
            if importOnly
              println( "file not present, aborting." )
              return
            else
              #TODO
              #println("Cannot create operator file: First create list file $tgtListFile")

            end
        end

        if isfile(outFileC)
           try
             # TODO: switch all internal storage to sms format
             cp(outFileC, outFile)
             #A = read_matrix_file_plain(outFileC)
             #if A != []
             #   write_matrix_file_sms(round(Int,A),outFile)
             #else
             #  println("Empty Matrix. TODO")
             #end
           catch y
             println(y)
             println("Couldn't read file")            
           end
           println("done.")
        else
           println("failed.")   
        end

end


#----- visualization ---------------------
function dispListCoverageOrdinaryWrapper(nDisplay=0)
  data = []
  nVR = collect(3:24)
  nLR=collect(2:15)

  for evenEdges in [true, false]
    curdata = Array{Any}(length(nVR), length(nLR))
    for (i,v) in enumerate(nVR)
      for (j,l) in enumerate(nLR)
        vs = OrdinaryGraphVectorSpaceWrapper(v,l,evenEdges)
        dim = getDimension(vs)
        deco = is_valid(vs) ? "" : "class=redcell"
        curdata[i,j] = Dict("data"=>dim, "style"=>deco)
      end
    end
    push!(data, curdata)
  end

  dispTables(["Even edges (vertices\\loops)", "Odd edges (vertices\\loops)"], Any[nLR, nLR], Any[nVR,nVR], data, nDisplay=nDisplay)

end