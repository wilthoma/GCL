#######################################################################
# provides a wrapper around the existing C++ code for generating 
# lists of ordinary graphs and the contraction operator.
#
# Keeps 2 copies of each file, one generated by the C++ code, 
# and one translated into "proper" format
#######################################################################


# here the translated copies of files reside, letters OE=odd edges, even hair(-vertices)
hairyDataDirWrapperOO = joinpath(DATA_DIR, "hairy_wrapper/OO/")
hairyDataDirWrapperOE = joinpath(DATA_DIR, "hairy_wrapper/OE/")
hairyDataDirWrapperEE = joinpath(DATA_DIR, "hairy_wrapper/EE/")
hairyDataDirWrapperEO = joinpath(DATA_DIR, "hairy_wrapper/EO/")

# here is where the C++ code creates its files
hairyDataDirWrapperC = joinpath(DATA_DIR, "hairy_wrapper/cdata/")


# Path to the C++ program
gradiff_hairy = "../ordinary_ccode/gradiff_hairy"
makemat_hairy = "../ordinary_ccode/makemat_hairy"

imgBaseDir = "img/"

type HairyGraphVectorSpaceWrapper <: GraphVectorSpace{SmallGraph}
  nVertices :: Int # this excludes hair vertices
  nLoops :: Int
  nHairs :: Int
  evenEdges :: Bool
  evenHairs :: Bool # this refers to the vertex at the end of the hair, not the whole hair
end

function get_dataDir(self::HairyGraphVectorSpaceWrapper)
    return self.evenEdges ? ( self.evenHairs ? hairyDataDirWrapperEE : hairyDataDirWrapperEO) : ( self.evenHairs ? hairyDataDirWrapperOE : hairyDataDirWrapperOO)
end

function get_file_name(self::HairyGraphVectorSpaceWrapper)
  dataDir = get_dataDir(self)
  s = @sprintf "gra%d_%d_%d.g6" self.nVertices self.nLoops self.nHairs
  return string(dataDir, s)
end

"""
  The cohomological degree, for dimension = 2 if edges are odd and dimension 3 if edges are even
"""
function get_degree(self::HairyGraphVectorSpaceWrapper)
  nEdges = self.nLoops + self.nVertices -1 + self.nHairs
  nVert = self.nVertices + self.nHairs
  return self.evenEdges ? 3*nVert-3-2*nEdges : 2*nVert-2-nEdges
end

function get_prefix(self::HairyGraphVectorSpaceWrapper)
  return self.evenEdges ? (self.evenHairs ? "graevohairy" : "graevhairy") : (self.evenHairs ? "grahairy" : "graohairy") 
end
"""
  The list file name to which the C++ code writes the list. 
  Mind that vector spaces with all numbers of hairs are generated simultaneously by gradiff_hairy.
"""
function get_file_nameC(self::HairyGraphVectorSpaceWrapper)
  degree = get_degree(self)
  prefix = get_prefix(self)

    s = "$prefix$(self.nVertices+self.nHairs)_$degree.g6" # mind: nHairs does not appear explicitly, cf. above
    return joinpath(hairyDataDirWrapperC, s)
end


function get_svg_dir(self::HairyGraphVectorSpaceWrapper)
  dataDir = get_dataDir(self)
  s = @sprintf "imgs%d_%d_%d/" self.nVertices self.nLoops self.nHairs
  return string(dataDir, imgBaseDir, s)
end


function get_color_counts(self::HairyGraphVectorSpaceWrapper)
        error("This routine should not be called, this is only a wrapper")
end

function get_fstring(self::HairyGraphVectorSpaceWrapper)
        error("This routine should not be called, this is only a wrapper")
end

"""Check whether the T graded subspace can in principle be non-empty.
   For each such T, a file is expected. Otherwise the corresponding
   graded component is considered not computed yet."""
function is_valid(self::HairyGraphVectorSpaceWrapper)
        nEdges = self.nLoops + self.nVertices -1
        # at least trivalent
        l = (3*self.nVertices <= 2*nEdges + self.nHairs)
        # all numbers positive
        l = l && self.nVertices > 0 && self.nLoops >= 0 && self.nHairs >=0
        # Can have at most a full graph
        l = l && nEdges <= self.nVertices*(self.nVertices-1)/2
        return l
end

function get_base(self::HairyGraphVectorSpaceWrapper)
    return HairyGraphVectorSpace(self.nVertices, self.nLoops, self.nHairs, self.evenEdges, self.evenHairs)
end

function get_generating_graphs(self::HairyGraphVectorSpaceWrapper)
    error("This routine should not be called, this is only a wrapper")
end

"""For G a graph and p a permutation of the edges, returns the sign induced by the relabelling by p.
   Here vertex j becomes vertex p[j] in the new graph."""
function get_perm_sign(self::HairyGraphVectorSpaceWrapper, G::SmallGraph, p)
    return get_perm_sign(get_base(self), G, p)
end

"""Converts the graph to a graphviz dot format string.
   This method is used only for visualization, not for computation."""
function get_dot(self::HairyGraphVectorSpaceWrapper, G)
    return get_dot(get_base(self), G)
end


# -----  Contraction operator --------

type ContractDHairyWrapper <: GraphOperator{SmallGraph,SmallGraph}
  # source
  nVertices :: Int
  nLoops :: Int
  nHairs :: Int
  evenEdges :: Bool
  evenHairs :: Bool
end


"""Returns target graph vector space."""
function get_target(self::ContractDHairyWrapper)
  return HairyGraphVectorSpaceWrapper(self.nVertices-1, self.nLoops, self.nHairs, self.evenEdges, self.evenHairs)
end

"""
Returns the GraphVectorSpace on which this operator acts
"""
function get_source(self::ContractDHairyWrapper)
  return HairyGraphVectorSpaceWrapper(self.nVertices, self.nLoops, self.nHairs, self.evenEdges, self.evenHairs)
end

"""Retrieve the file name of the file storing the matrix list for the operator."""
function get_file_name(self::ContractDHairyWrapper)
  dataDir = get_dataDir(get_source(self))
  s = @sprintf "contractD%d_%d_%d.txt" self.nVertices self.nLoops self.nHairs
  return joinpath(dataDir, s)
end

function get_unique_file_name(self::ContractDHairyWrapper)
  prefix = "hairy_" * (self.evenEdges ? "E":"O") * (self.evenHairs ? "E":"O") * "_"
  s = @sprintf "contractDWrapper%d_%d.sms" self.nVertices self.nLoops
  return string(prefix, s)
end


"""
Mind again that gradiff_hairy computes all nrs of hairs simultaneously.
"""
function get_file_nameC(self::ContractDHairyWrapper)
  svs = get_source(self)
  degree = get_degree(svs)
  prefix = get_prefix(svs)

 
    s = "$prefix$(self.nVertices+self.nHairs)_$degree.txt"
    return joinpath(hairyDataDirWrapperC, s)
  
end


function operate_on(self::ContractDOrdinaryWrapper, G::SmallGraph)
    error("This should not be called")
end

function get_work_estimate(self::HairyGraphVectorSpaceWrapper)
  # give estimate of number of graphs
  nEdges = self.nLoops + self.nVertices -1
  n = self.nVertices
  return binomial(div(n*(n-1),2), nEdges) / factorial(n)
end

function get_work_estimate(self::ContractDHairyWrapper)
  # give estimate of number of graphs
  vs = get_source(self)
  nEdges = vs.nLoops + vs.nVertices -1
  return get_work_estimate(vs) * nEdges
end



# ------ Overloads of creation functions ---------------
"""
Creates the list file for a single graph vector space.
importOnly: if true, the C++ code is not called, only existing files are imported
"""
function createListFile(self::HairyGraphVectorSpaceWrapper;importOnly=false, skipExisting=false)
        if !is_valid(self)
          return
        end
        
        outFile = get_file_name(self)
        outFileC = get_file_nameC(self)
        outDir = dirname(outFile)
        outDirC = dirname(outFileC)
    
        if skipExisting && isfile(outFile)
            println("Skipped") 
            return
        end

        if !isdir(outDir)
            mkpath(outDir)
        end

        println( string( "Creating File ",outFile,"...") )
        #println("welt")

        if !isfile(outFileC)
          if importOnly
             println( outFileC * ": file not present, aborting." )
             return
          else
             if !isdir(outDirC)
                mkpath(outDirC)
             end
             println( "Calling external program." )
             degree = get_degree(self)
             run(`$gradiff_hairy -l $(self.evenEdges?"-e":"") $(self.evenHairs==self.evenEdges?"-o":"") -d$degree $(self.nVertices+self.nHairs) $outFileC`)
          end
        end

        if isfile(outFileC)
            # pick only the part of the file with correct number of hairs
            if filesize(outFileC)>0
              A = readdlm(outFileC)
              B=A[A[:,2].==self.nHairs,3]
              writedlm(outFile, B)
             else
               # write an empty file 
               fff=open(outFile, "w")
               close(fff)
             end
            
            println( "copied." )
        else
           println("failed!")
        end
        
end


"""
Creates the matrix file that holds the operator.
The corresponding list files for source and target
must exist when calling this function.
"""
function createOperatorFile(self::ContractDHairyWrapper;importOnly=false, skipExisting=false)

        if !is_valid_op(self)
          return
        end

        #vs = get_source(self)
        outFile = get_file_name(self)
        outFileC = get_file_nameC(self)
        #inListFileC = get_file_nameC(vs)
        src = get_source(self)
        tgt = get_target(self)
        #tgtListFileC = get_file_nameC(tvs)

        if skipExisting && isfile(outFile)
            println("Skipped") 
            return
        end

        println( string( "Creating File ",outFile,"...") )

        if !isfile(outFileC)
            if importOnly
              println( outFileC*": file not present, aborting." )
              return
            else
              
              tgtListFileC = get_file_nameC(tgt)
              preoutFileC = outFileC[1:end-3] * "hg6" # change ending
              if !isfile(tgtListFileC)
                println("List file does not exist: "*tgtListFileC*"...skipping.")
                return                 
              end

              degree= get_degree(src)
              
              run(`$gradiff_hairy $(self.evenEdges?"-e":"") $(self.evenHairs==self.evenEdges?"-o":"") -d$degree $(self.nVertices+self.nHairs) $outFileC`)
          
              # make matrix file
              println("Creating matrix....")
              println(`$makemat_hairy $tgtListFileC $preoutFileC`)
              run(pipeline(`$makemat_hairy $tgtListFileC $preoutFileC`,outFileC) )
              println("Done.")
            end
        end

        if isfile(outFileC)
           try
             # TODO: switch all internal storage to sms format
             #mycp(outFileC, outFile)
             #A = read_matrix_file_plain(outFileC)
             #if A != []
             #   write_matrix_file_sms(round(Int,A),outFile)
             #else
             #  println("Empty Matrix. TODO")
             #end
             if filesize(outFileC)>0
               A = readdlm(outFileC)
               B = A[A[:,1].==self.nHairs,2:3]
               writedlm(outFile, B)
             else
               # write an empty file 
               fff=open(outFile, "w")
               close(fff)
             end

           catch y
             println(y)
             println("Couldn't read file")            
           end
           println("done.")
        else
           println("failed.")   
        end

end





#----- visualization ---------------------
function dispListCoverageHairyWrapper(nDisplay=0)
  data = []
  nVR = collect(3:24)
  nLR=collect(2:15)
  nHR=collect(1:15)
  captions=[]
  xHdrs=[]
  yHdrs=[]

  for evenEdges in [true, false]
   for evenHairs in [true, false]
   for (k,h) in enumerate(nHR) 
    curdata = Array{Any}(length(nVR), length(nLR))
    for (i,v) in enumerate(nVR)
      for (j,l) in enumerate(nLR)        
          vs = HairyGraphVectorSpaceWrapper(v,l,h,evenEdges, evenHairs)
          dim = getDimension(vs)
          deco = is_valid(vs) ? "" : "class=redcell"
          curdata[i,j] = Dict("data"=>dim, "style"=>deco)
      end
    end
    push!(data, curdata)
    push!(captions, "$h-HairyWrapper"*(evenEdges?"E":"O")*(evenHairs?"E":"O")*" (vertices\\loops)" )
    push!(xHdrs, nLR)
    push!(yHdrs, nVR)
    end
   end
  end

  dispTables(captions, xHdrs, yHdrs, data, nDisplay=nDisplay)

end


"""
  Shows a table of the file size of operator.
  Or -1 if operator could not be loaded.
  The number in brackets is the rank, or -1 if not computed
"""
function dispOperatorCoverageHairyWrapper(nDisplay=0)
  data = []
  nVR = collect(3:24)
  nLR=collect(2:15)
  nHR=collect(1:15)
  captions=[]
    xHdrs=[]
  yHdrs=[]

  for evenEdges in [true, false]
   for evenHairs in [true, false]
   for (k,h) in enumerate(nHR) 
    curdata = Array{Any}(length(nVR), length(nLR))
    for (i,v) in enumerate(nVR)
      for (j,l) in enumerate(nLR)        
          theop=ContractDHairyWrapper(v,l,h,evenEdges, evenHairs)
          fsize = -1
          try
            fff = get_file_name(theop)
            if isfile(fff)
              fsize=filesize(fff)
            end 
          catch
          end

        rnk = readRank(theop)        
        deco = is_valid_op(theop) ? "" : "class=redcell"
        curdata[i,j] = Dict("data"=>"$fsize ($rnk)", "style"=>deco)
      end
    end
    push!(data, curdata)
    push!(captions, "ContractDWrapper $h-Hairy"*(evenEdges?"E":"O")*(evenHairs?"E":"O")*" (vertices\\loops)" )
        push!(xHdrs, nLR)
    push!(yHdrs, nVR) 
    end
   end
   end

    dispTables(captions, xHdrs, yHdrs, data, nDisplay=nDisplay)

end

function dispCohomologyHairyWrapper(nDisplay=0)
  data = []
  nVR = collect(3:24)
  nLR=collect(2:15)
  nHR=collect(1:15)
  captions=[]
    xHdrs=[]
  yHdrs=[]

  for evenEdges in [true, false]
   for evenHairs in [true, false]
     for (k,h) in enumerate(nHR) 
        curdata = Array{Any}(length(nVR), length(nLR))
        for (i,v) in enumerate(nVR)
            for (j,l) in enumerate(nLR)        
                vs = HairyGraphVectorSpaceWrapper(v,l,h,evenEdges,evenHairs)
                op = ContractDHairyWrapper(v,l,h,evenEdges,evenHairs)
                op2 = ContractDHairyWrapper(v+1,l,h,evenEdges,evenHairs)

                dim = get_cohomology_by_rank(op, op2)
                deco = is_valid(vs) ? "" : "class=redcell"
                curdata[i,j] = Dict("data"=>dim, "style"=>deco)
            end
        end
        push!(data, curdata)
        push!(captions, "Cohomology Wrapper $h-Hairy"*(evenEdges?"E":"O")*(evenHairs?"E":"O")*" (vertices\\loops)" )
        push!(xHdrs, nLR)
        push!(yHdrs, nVR)
     end 
    end
   end
  
    dispTables(captions, xHdrs, yHdrs, data, nDisplay=nDisplay)


end

