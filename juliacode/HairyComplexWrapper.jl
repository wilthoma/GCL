#######################################################################
# provides a wrapper around the existing C++ code for generating 
# lists of ordinary graphs and the contraction operator.
#
# Keeps 2 copies of each file, one generated by the C++ code, 
# and one translated into "proper" format
#######################################################################


# here the translated copies of files reside, letters OE=odd edges, even hair(-vertices)
hairyDataDirWrapperOO = joinpath(DATA_DIR, "hairy_wrapper/OO/")
hairyDataDirWrapperOE = joinpath(DATA_DIR, "hairy_wrapper/OE/")
hairyDataDirWrapperEE = joinpath(DATA_DIR, "hairy_wrapper/EE/")
hairyDataDirWrapperEO = joinpath(DATA_DIR, "hairy_wrapper/EO/")

# here is where the C++ code creates its files
hairyDataDirWrapperC = joinpath(DATA_DIR, "hairy_wrapper/cdata/")


# Path to the C++ program
programC = "../ordinary_ccode/gradiff_hairy"
makematC = "../ordinary_ccode/makemat_hairy"

imgBaseDir = "img/"

type HairyGraphVectorSpaceWrapper <: GraphVectorSpace{SmallGraph}
  nVertices :: Int # this excludes hair vertices
  nLoops :: Int
  nHairs :: Int
  evenEdges :: Bool
  evenHairs :: Bool # this refers to the vertex at the end of the hair, not the whole hair
end

function get_dataDir(self::HairyGraphVectorSpaceWrapper)
    return self.evenEdges ? ( self.evenHairs ? hairyDataDirWrapperEE : hairyDataDirWrapperEO) : ( self.evenHairs ? hairyDataDirWrapperOE : hairyDataDirWrapperOO)
end

function get_file_name(self::HairyGraphVectorSpaceWrapper)
  dataDir = get_dataDir(self)
  s = @sprintf "gra%d_%d_%d.g6" self.nVertices self.nLoops self.nHairs
  return string(dataDir, s)
end

"""
  The cohomological degree, for dimension = 2 if edges are odd and dimension 3 if edges are even
"""
function get_degree(self::HairyGraphVectorSpaceWrapper)
  nEdges = self.nLoops + self.nVertices -1 + self.nHairs
  nVert = self.nVertices + self.nHairs
  return self.evenEdges ? 3*nVert-3-2*nEdges : 2*nVert-2-nEdges
end

"""
  The list file name to which the C++ code writes the list. 
"""
function get_file_nameC(self::HairyGraphVectorSpaceWrapperBlock)
  degree = get_degree(self)
  prefix = self.evenEdges ? (self.evenHairs ? "graevohairy" : "graevhairy") : (self.evenHairs ? "grahairy" : "graohairy") 

    s = "$prefix$(self.nVertices+self.nHairs)_$degree.g6"
    return joinpath(hairyDataDirWrapperC, s)
end


function get_svg_dir(self::HairyGraphVectorSpaceWrapper)
  dataDir = get_dataDir(self)
  s = @sprintf "imgs%d_%d_%d/" self.nVertices self.nLoops self.nHairs
  return string(dataDir, imgBaseDir, s)
end


function get_color_counts(self::HairyGraphVectorSpaceWrapper)
        error("This routine should not be called, this is only a wrapper")
end

function get_fstring(self::HairyGraphVectorSpaceWrapper)
        error("This routine should not be called, this is only a wrapper")
end

"""Check whether the T graded subspace can in principle be non-empty.
   For each such T, a file is expected. Otherwise the corresponding
   graded component is considered not computed yet."""
function is_valid(self::HairyGraphVectorSpaceWrapper)
        nEdges = self.nLoops + self.nVertices -1
        # at least trivalent
        l = (3*self.nVertices <= 2*nEdges + self.nHairs)
        # all numbers positive
        l = l && self.nVertices > 0 && self.nLoops >= 0 && self.nHairs >=0
        # Can have at most a full graph
        l = l && nEdges <= self.nVertices*(self.nVertices-1)/2
        return l
end

#function get_base(self::HairyGraphVectorSpaceWrapper)
#    return HairyGraphVectorSpace(self.nVertices, self.nLoops, self.evenEdges)
#end

"""Produces a set of graphs whose isomorphism classes span the T component of the vector space.
   (Not necessarily freely!)"""
function get_generating_graphs(self::HairyGraphVectorSpaceWrapper)
    error("This routine should not be called, this is only a wrapper")
end

"""For G a graph and p a permutation of the edges, returns the sign induced by the relabelling by p.
   Here vertex j becomes vertex p[j] in the new graph."""
#function get_perm_sign(self::HairyGraphVectorSpaceWrapper, G::SmallGraph, p)
#    return get_perm_sign(get_base(self), G, p)
#end

"""Converts the graph to a graphviz dot format string.
   This method is used only for visualization, not for computation."""
#function get_dot(self::OrdinaryGraphVectorSpaceWrapper, G)
#    return get_dot(get_base(self), G)
#end


# -----  Contraction operator --------

type ContractDHairyWrapper <: GraphOperator{SmallGraph,SmallGraph}
  # source
  nVertices :: Int
  nLoops :: Int
  nHairs :: Int
  evenEdges :: Bool
  evenHairs :: Bool
end


"""Returns target graph vector space."""
function get_target(self::ContractDHairyWrapper)
  return HairyGraphVectorSpaceWrapper(self.nVertices-1, self.nLoops, self.nHairs, self.evenEdges, self.evenHairs)
end

"""
Returns the GraphVectorSpace on which this operator acts
"""
function get_source(self::ContractDHairyWrapper)
  return HairyGraphVectorSpaceWrapper(self.nVertices, self.nLoops, self.nHairs, self.evenEdges, self.evenHairs)
end

"""Retrieve the file name of the file storing the matrix list for the operator."""
function get_file_name(self::ContractDHairyWrapper)
  dataDir = get_dataDir(get_source(self))
  s = @sprintf "contractD%d_%d_%d.txt" self.nVertices self.nLoops self.nHairs
  return joinpath(dataDir, s)
end

function get_unique_file_name(self::ContractDOrdinaryWrapper)
  prefix = "hairy_" * (self.evenEdges ? "E":"O") * (self.evenHairs ? "E":"O") * "_"
  s = @sprintf "contractDWrapper%d_%d.sms" self.nVertices self.nLoops
  return string(prefix, s)
end

"""
function get_file_nameC(self::ContractDOrdinaryWrapper)
  svs = get_source(self)
  degree = get_degree(svs)

  if self.evenEdges
    s = @sprintf "graev%d_%d.txt" self.nVertices degree
    return joinpath(ordinaryDataDirWrapperEvenC, s)
  else
    s = @sprintf "gra%d_%d.txt" self.nVertices degree
    return joinpath(ordinaryDataDirWrapperOddC, s)
  end 
end
"""

"""For G a graph returns a list of pairs (GG, x),
   such that (operator)(G) = sum x GG.
"""
function operate_on(self::ContractDOrdinaryWrapper, G::SmallGraph)
    error("This should not be called")
end

function get_work_estimate(self::OrdinaryGraphVectorSpaceWrapper)
  # give estimate of number of graphs
  nEdges = self.nLoops + self.nVertices -1
  n = self.nVertices
  return binomial(div(n*(n-1),2), nEdges) / factorial(n)
end

function get_work_estimate(self::ContractDOrdinaryWrapper)
  # give estimate of number of graphs
  vs = get_source(self)
  nEdges = vs.nLoops + vs.nVertices -1
  return get_work_estimate(vs) * nEdges
end



# ------ Overloads of creation functions ---------------
"""
Creates the list file for a single graph vector space.
importOnly: if true, the C++ code is not called, only existing files are imported
"""
function createListFile(self::OrdinaryGraphVectorSpaceWrapper;importOnly=false, skipExisting=false)
        if !is_valid(self)
          return
        end
        
        outFile = get_file_name(self)
        outFileC = get_file_nameC(self)
        outDir = dirname(outFile)
        outDirC = dirname(outFileC)
    
        if skipExisting && isfile(outFile)
            println("Skipped") 
            return
        end

        if !isdir(outDir)
            mkpath(outDir)
        end

        println( string( "Creating File ",outFile,"...") )
        #println("welt")

        if !isfile(outFileC)
          if importOnly
             println( outFileC * ": file not present, aborting." )
             return
          else
             if !isdir(outDirC)
                mkpath(outDirC)
             end
             println( "Calling external program." )
             degree = get_degree(self)
             if self.evenEdges
                run(`$programC -l -e -d$degree $(self.nVertices) $outFileC`)
             else
                run(`$programC -l -d$degree $(self.nVertices) $outFileC`)
             end
          end
        end

        if isfile(outFileC)
            mycp(outFileC, outFile)
            println( "copied." )
        else
           println("failed!")
        end
        
end


"""
Creates the matrix file that holds the operator.
The corresponding list files for source and target
must exist when calling this function.
"""
function createOperatorFile(self::ContractDOrdinaryWrapper;importOnly=false, skipExisting=false)

        if !is_valid_op(self)
          return
        end

        #vs = get_source(self)
        outFile = get_file_name(self)
        outFileC = get_file_nameC(self)
        #inListFileC = get_file_nameC(vs)
        src = get_source(self)
        tgt = get_target(self)
        #tgtListFileC = get_file_nameC(tvs)

        if skipExisting && isfile(outFile)
            println("Skipped") 
            return
        end

        println( string( "Creating File ",outFile,"...") )

        if !isfile(outFileC)
            if importOnly
              println( outFileC*": file not present, aborting." )
              return
            else
              
              tgtListFileC = get_file_nameC(tgt)
              preoutFileC = outFileC[1:end-3] * "hg6" # change ending
              if !isfile(tgtListFileC)
                println("List file does not exist: "*tgtListFileC*"...skipping.")
                return                 
              end

              degree= get_degree(src)
              
              if self.evenEdges
                run(`$programC -e -d$degree $(self.nVertices) $preoutFileC`)
              else
                run(`$programC -d$degree $(self.nVertices) $preoutFileC`)
              end

              # make matrix file
              println("Creating matrix....")
              println(`$makematC $tgtListFileC $preoutFileC`)
              run(pipeline(`$makematC $tgtListFileC $preoutFileC`,outFileC) )
              println("Done.")
            end
        end

        if isfile(outFileC)
           try
             # TODO: switch all internal storage to sms format
             mycp(outFileC, outFile)
             #A = read_matrix_file_plain(outFileC)
             #if A != []
             #   write_matrix_file_sms(round(Int,A),outFile)
             #else
             #  println("Empty Matrix. TODO")
             #end
           catch y
             println(y)
             println("Couldn't read file")            
           end
           println("done.")
        else
           println("failed.")   
        end

end





#----- visualization ---------------------
function dispListCoverageOrdinaryWrapper(nDisplay=0)
  data = []
  nVR = collect(3:24)
  nLR=collect(2:15)

  for evenEdges in [true, false]
    curdata = Array{Any}(length(nVR), length(nLR))
    for (i,v) in enumerate(nVR)
      for (j,l) in enumerate(nLR)
        vs = OrdinaryGraphVectorSpaceWrapper(v,l,evenEdges)
        dim = getDimension(vs)
        deco = is_valid(vs) ? "" : "class=redcell"
        curdata[i,j] = Dict("data"=>dim, "style"=>deco)
      end
    end
    push!(data, curdata)
  end

  dispTables(["Even edges (vertices\\loops)", "Odd edges (vertices\\loops)"], Any[nLR, nLR], Any[nVR,nVR], data, nDisplay=nDisplay)

end


"""
  Shows a table of the file size of operator.
  Or -1 if operator could not be loaded.
  The number in brackets is the rank, or -1 if not computed
"""
function dispOperatorCoverageOrdinaryWrapper(nDisplay=0)
  data = []
  nVR = collect(3:25)
  nLR=collect(2:15)

  for evenEdges in [true, false]
    curdata = Array{Any}(length(nVR), length(nLR))
    for (i,v) in enumerate(nVR)
      for (j,l) in enumerate(nLR)
        #vs = OrdinaryGraphVectorSpaceWrapper(v,l,evenEdges)
        theop=ContractDOrdinaryWrapper(v,l,evenEdges)
        fsize = -1
        try
          #D = load_matrix(theop)
          #if D==[]
          #  nrEntries = 0
          #else
          #  nrEntries = nnz(D)
          #end
          fff = get_file_name(theop)
          if isfile(fff)
            fsize=filesize(fff)
          end 
        catch
        end

        rnk = readRank(theop)
        
        deco = is_valid_op(theop) ? "" : "class=redcell"

        curdata[i,j] = Dict("data"=>"$rnk", "style"=>deco)
      end
    end
    push!(data, curdata)
  end

  dispTables(["Even edges (vertices\\loops)", "Odd edges (vertices\\loops)"], Any[nLR, nLR], Any[nVR,nVR], data, nDisplay=nDisplay)

end

function dispCohomologyOrdinaryWrapper(nDisplay=0)
  data = []
  nVR = collect(3:20)
  nLR=collect(2:10)

  for evenEdges in [true, false]
    curdata = Array{Any}(length(nVR), length(nLR))
    for (i,v) in enumerate(nVR)
      for (j,l) in enumerate(nLR)
        vs = OrdinaryGraphVectorSpaceWrapper(v,l,evenEdges)
        op = ContractDOrdinaryWrapper(v,l,evenEdges)
        op2 = ContractDOrdinaryWrapper(v+1,l,evenEdges)

        dim = get_cohomology_by_rank(op, op2)
        deco = is_valid(vs) ? "" : "class=redcell"
        curdata[i,j] = Dict("data"=>dim, "style"=>deco)
      end
    end
    push!(data, curdata)
  end

  dispTables(["Cohomology Even edges (vertices\\loops)", "Cohomology Odd edges (vertices\\loops)"], Any[nLR, nLR], Any[nVR,nVR], data, nDisplay=nDisplay)

end